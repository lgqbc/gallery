<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'unsafe-inline' https://cdn.tailwindcss.com; img-src 'self' https:; style-src 'unsafe-inline' https://cdn.tailwindcss.com; connect-src 'self' https://api.github.com">
  <title>Gallery</title>
  <script src="https://cdn.tailwindcss.com"></script>

<!-- custom colors -->
  <script>tailwind.config={theme:{extend:{colors:{coal:"#111111"}}}};</script>

  <style>
    @media (hover: none) {
      .hover\:opacity-100 { opacity: 0.6 !important; }
    }
    html, body {overflow-x: hidden;}

    /* Make SVG icons white */
    #prev img, #next img, #gridBtn img, #openPopup img {
      filter: brightness(0) invert(1);
    }
  </style>
</head>
<body class="bg-coal text-gray-400">

<div id="fullscreen" class="flex items-center justify-center h-screen relative">
  <div id="title" class="hidden absolute bottom-5 left-5 md:left-12 text-2xl"></div>

  <div class="flex items-center justify-center h-screen relative select-none">
    <img id="image" class="rounded-md
      max-w-[100%] 2xl:max-w-[100%] max-h-[100%] 2xl:max-h-[95%] 
      object-contain" src="" alt="">
    <div id="prev" class="text-white opacity-25 hover:opacity-40 active:opacity-40 fixed cursor-pointer z-50">
      <img src="icons/prev.svg" alt="Previous" class="w-12 h-12 sm:w-20 sm:h-20">
    </div>
    <div id="next" class="text-white opacity-25 hover:opacity-40 active:opacity-40 fixed cursor-pointer z-50">
      <img src="icons/next.svg" alt="Next" class="w-12 h-12 sm:w-20 sm:h-20">
    </div>
  </div>
  
  <button id="gridBtn" class="fixed px-3 py-2 opacity-50 hover:opacity-70 active:opacity-70 z-10">
    <img src="icons/gridBtn.svg" alt="Grid" class="w-12 h-12 sm:w-16 h-16">
  </button>
  <button id="openPopup" class="fixed px-3 py-2 opacity-50 hover:opacity-70 active:opacity-70 z-10">
    <img src="icons/openPopup.svg" alt="Info" class="w-12 h-12 sm:w-16 h-16">
  </button>

  <div id="dotsBar" class="fixed flex gap-3 z-10 scale-[60%] sm:scale-100"></div>

  <!-- Clickable left half for previous -->
  <div id="prev-area" class="absolute top-0 left-0 bottom-36 sm:bottom-6 w-1/2 cursor-pointer -z-2"></div>
  <!-- Clickable right half for next -->
  <div id="next-area" class="absolute top-0 right-0 bottom-36 sm:bottom-6 w-1/2 cursor-pointer -z-2"></div>
  
</div>

  
<div id="grid" class="hidden bg-coal min-h-screen px-5 md:px-12 2xl:px-24 py-5 md:py-12">
   <button id="closeGrid" class="text-4xl sm:text-6xl absolute top-3 right-5 px-2 py-0 text-gray-300 bg-transparent rounded-full opacity-50 hover:opacity-70 z-10 scale-150">×</button>
  <div id="gridContainer" class="grid gap-2 md:gap-5 lg:gap-10 grid-cols-2 lg:grid-cols-3"></div>
</div>

<!-- Welcome popup (shows only if user hasn't closed it yet) -->
<div id="welcomePopup"
     class="backdrop-blur-md fixed inset-0 bg-coal/50 filter saturate-10 flex items-center justify-center z-50 hidden text-sm sm:text-sm">
  <div class="opacity-50 bg-black text-gray-200 p-3 sm:p-6 rounded-xl max-w-[75%] xl:max-w-[25%] text-justify">
    <h2 class="text-xl text-semibold mb-2">hello.</h2>
    <p class="mb-2 sm:mb-4 italic">you found my gallery. how did you end up here?
      <br><br>all photos are unedited - as shot - on a 2004 digicam.</p>
    <p class="italic text-gray-600">bofu/2026</p>
    <p class="mb-1 italic text-gray-600 text-sm">contact: lukas.gilow@gmail.com</p>
    <br>
    <div class="w-full flex justify-center">
      <button id="closePopup"
              class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:opacity-80">
        Continue
      </button>
    </div>
  </div>
</div>
  
<script>

// Show welcome popup only if user has NOT closed it before
    const popup = document.getElementById("welcomePopup");
    const closeBtn = document.getElementById("closePopup");
    const openBtn = document.getElementById("openPopup");
  
// Show popup on first visit (unless closed before)
    if (!localStorage.getItem("closedPopup")) {
      popup.classList.remove("hidden");
    }
  
// Close
    closeBtn.onclick = () => {
      popup.classList.add("hidden");
      localStorage.setItem("closedPopup", "true");
    };
  
// Re-open manually whenever the user wants
    openBtn.onclick = () => {
      popup.classList.remove("hidden");
    };
    
  let images = [];
  let current = 0;

// pre-load images
  function preloadImage(url) {
  const img = new Image();
  img.src = url;
}

// Inside render(), after updating current image:
if (current < images.length - 1) preloadImage(images[current + 1].url);
if (current > 0) preloadImage(images[current - 1].url);

  async function loadImages() {
    await new Promise(r => setTimeout(r, 500));
    try {
      const response = await fetch('https://api.github.com/repos/lgqbc/gallery/contents/images');
      const data = await response.json();
      images = data.filter(f => /\.(jpg|jpeg|png|gif|webp)$/i.test(f.name)).map(f => ({
        name: f.name.replace(/\.[^/.]+$/, ''),
        url: f.download_url
      }));
      render();
    } catch (e) {
      document.getElementById('title').textContent = 'Error loading images';
    }
  }

// Position all elements based on image bounds
function positionElements() {
  const imgEl = document.getElementById('image');
  const prevEl = document.getElementById('prev');
  const nextEl = document.getElementById('next');
  const gridBtnEl = document.getElementById('gridBtn');
  const openPopupEl = document.getElementById('openPopup');
  const dotsBarEl = document.getElementById('dotsBar');

  // FIXED: Always use landscape aspect ratio (3072/2304) for UI positioning
  const LANDSCAPE_RATIO = 3072 / 2304; // 1.333...

  // Get viewport dimensions
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  // Calculate hypothetical landscape image bounds
  let hypotheticalWidth, hypotheticalHeight;

  // Check which dimension constrains the image (respecting max-height constraints)
  const maxHeight = window.innerWidth >= 1536 ? viewportHeight * 0.95 : viewportHeight;

  if (viewportWidth / maxHeight > LANDSCAPE_RATIO) {
    // Height-constrained
    hypotheticalHeight = maxHeight;
    hypotheticalWidth = hypotheticalHeight * LANDSCAPE_RATIO;
  } else {
    // Width-constrained
    hypotheticalWidth = viewportWidth;
    hypotheticalHeight = hypotheticalWidth / LANDSCAPE_RATIO;
  }

  // Calculate hypothetical position (centered)
  const hypotheticalLeft = (viewportWidth - hypotheticalWidth) / 2;
  const hypotheticalTop = (viewportHeight - hypotheticalHeight) / 2;
  let hypotheticalRight = hypotheticalLeft + hypotheticalWidth;
  let hypotheticalBottom = hypotheticalTop + hypotheticalHeight;

  // Constrain right edge to ensure buttons fit within viewport
  const MIN_RIGHT_SPACE = 80; // minimum space for buttons (accounting for button width + transform)
  hypotheticalRight = Math.min(hypotheticalRight, viewportWidth - MIN_RIGHT_SPACE);

  // Recalculate width after clamping
  const clampedWidth = hypotheticalRight - hypotheticalLeft;
  const clampedHeight = hypotheticalHeight;

  // Use hypothetical bounds for positioning (as if image were always landscape)
  const imgRect = {
    left: hypotheticalLeft,
    right: hypotheticalRight,
    top: hypotheticalTop,
    bottom: hypotheticalBottom,
    width: clampedWidth,
    height: clampedHeight
  };

  // Calculate space on each side
  const leftSpace = imgRect.left;
  const rightSpace = viewportWidth - imgRect.right;
  const topSpace = imgRect.top;

  const MIN_SPACE_FOR_CENTERING = 24; // 2 * 12px
  const FALLBACK_DISTANCE = 12; // px from screen edge
  const isMobile = window.innerWidth < 640; // sm breakpoint
  const isMedium = window.innerWidth >= 640 && window.innerWidth < 1024; // md breakpoint
  const ARROW_INWARD_OFFSET_MEDIUM = 15; // px to shift arrows inward on medium screens
  const BUTTON_INWARD_OFFSET = 20; // px to shift menu buttons inward on mobile/tablet

  // === ARROWS: Vertically center with image ===
  const verticalCenter = imgRect.top + (imgRect.height / 2);
  prevEl.style.top = `${verticalCenter}px`;
  nextEl.style.top = `${verticalCenter}px`;

  // Use transform to center the arrows on the calculated position
  prevEl.style.transform = 'translate(-50%, -50%)';
  nextEl.style.transform = 'translate(50%, -50%)'; // +50% for right-positioned element

  // Position arrows
  if (isMobile) {
    // Mobile: fixed distance from screen edges (on top of image)
    prevEl.style.left = `${FALLBACK_DISTANCE}px`;
    nextEl.style.right = `${FALLBACK_DISTANCE}px`;
    nextEl.style.left = 'auto';
  } else {
    // Desktop/Medium: center in margin space, or fallback if not enough space
    const arrowOffset = isMedium ? ARROW_INWARD_OFFSET_MEDIUM : 0;

    if (leftSpace >= MIN_SPACE_FOR_CENTERING) {
      prevEl.style.left = `${(leftSpace / 2) + arrowOffset}px`;
    } else {
      prevEl.style.left = `${FALLBACK_DISTANCE + arrowOffset}px`;
    }

    if (rightSpace >= MIN_SPACE_FOR_CENTERING) {
      nextEl.style.right = `${(rightSpace / 2) + arrowOffset}px`;
      nextEl.style.left = 'auto';
    } else {
      nextEl.style.right = `${FALLBACK_DISTANCE + arrowOffset}px`;
      nextEl.style.left = 'auto';
    }
  }

  // === BUTTONS: Fixed vertical positions at top, horizontal positioning like right arrow ===
  gridBtnEl.style.top = '24px';
  function setPopupTop() {
    openPopupEl.style.top = window.innerWidth < 640 ? '100px' : '125px';
  }
  setPopupTop();
  window.addEventListener('resize', setPopupTop); // Stack below grid button

  // Use same transform as arrows (right-positioned elements need +50%)
  gridBtnEl.style.transform = 'translateX(50%)';
  openPopupEl.style.transform = 'translateX(50%)';

  // Horizontal positioning - same logic as right arrow
  // Apply inward offset on mobile and tablet only
  const buttonOffset = (isMobile || isMedium) ? BUTTON_INWARD_OFFSET : 0;

  if (isMobile) {
    // Mobile: fixed distance from screen edge with inward offset
    gridBtnEl.style.right = `${FALLBACK_DISTANCE + buttonOffset}px`;
    gridBtnEl.style.left = 'auto';
    openPopupEl.style.right = `${FALLBACK_DISTANCE + buttonOffset}px`;
    openPopupEl.style.left = 'auto';
  } else {
    // Desktop/Medium: center in margin space with offset, or fallback if not enough space
    if (rightSpace >= MIN_SPACE_FOR_CENTERING) {
      gridBtnEl.style.right = `${(rightSpace / 2) + buttonOffset}px`;
      gridBtnEl.style.left = 'auto';
      openPopupEl.style.right = `${(rightSpace / 2) + buttonOffset}px`;
      openPopupEl.style.left = 'auto';
    } else {
      gridBtnEl.style.right = `${FALLBACK_DISTANCE + buttonOffset}px`;
      gridBtnEl.style.left = 'auto';
      openPopupEl.style.right = `${FALLBACK_DISTANCE + buttonOffset}px`;
      openPopupEl.style.left = 'auto';
    }
  }

  // === DOTS BAR: Smart positioning based on available space ===
  const spaceBelow = viewportHeight - imgRect.bottom;
  const SPACE_THRESHOLD = 10; // px threshold for "very little space"
  const INSIDE_MARGIN = 20; // margin from bottom when positioned inside image

  let dotsY;
  if (spaceBelow > SPACE_THRESHOLD) {
    // Center in the blank space below image
    dotsY = imgRect.bottom + (spaceBelow / 2);
  } else {
    // Stick to inside bottom of image with margin
    dotsY = imgRect.bottom - INSIDE_MARGIN;
  }

  const dotsX = imgRect.left + (imgRect.width / 2);
  dotsBarEl.style.top = `${dotsY}px`;
  dotsBarEl.style.left = `${dotsX}px`;

  // Apply scale based on viewport width (mobile vs desktop)
  const scaleValue = isMobile ? 0.6 : 1;
  dotsBarEl.style.transform = `translateX(-50%) scale(${scaleValue})`;
}

function render() {
  const fs = document.getElementById('fullscreen');
  const g = document.getElementById('grid');
  const imgEl = document.getElementById('image');

  // Switch the image immediately
  imgEl.src = images[current].url;

  if (fs.classList.contains('flex')) {
    const image = images[current];

    // Update title
    document.getElementById('title').textContent = image.name.startsWith("DSC") ? "" : image.name;

    // Show/hide arrows
    document.getElementById('prev').style.display = current === 0 ? 'none' : 'block';
    document.getElementById('next').style.display = current === images.length - 1 ? 'none' : 'block';

    // Position elements after image loads
    imgEl.onload = positionElements;
    // Also position immediately in case image is cached
    if (imgEl.complete && imgEl.naturalHeight !== 0) {
      positionElements();
    }

    // Update dots
    document.getElementById('dotsBar').innerHTML = images.map((_, i) => {
      const isActive = i === current;
      return `
        <div class="relative cursor-pointer ${isActive ? '' : 'group'}" onclick="setCurrent(${i})">
          <div class="absolute inset-[-7px]"></div>
          <div class="w-2 h-2 bg-slate-300 rounded-full ${isActive ? 'opacity-[1]' : 'opacity-[0.25] group-hover:opacity-[.65]'}"></div>
        </div>
      `;
    }).join('');
  } else {
    // Grid view
    document.getElementById('gridContainer').innerHTML = images.map((img, i) =>
      `<div class="select-none cursor-pointer overflow-hidden aspect-square rounded-lg" onclick="setCurrent(${i})">
         <img src="${img.url}" alt="${img.name}" class="w-full h-full object-cover">
       </div>`
    ).join('');
  }
}

  function setCurrent(i) {
    current = i;
    document.getElementById('fullscreen').classList.remove('hidden');
    document.getElementById('fullscreen').classList.add('flex');
    document.getElementById('grid').classList.add('hidden');
    render();
  }

// --- Swipe gestures for mobile ---
const fs = document.getElementById('fullscreen');
let startX = 0;
let startY = 0;
let isSwiping = false;

fs.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    startX = e.touches[0].clientX;
    startY = e.touches[0].clientY;
    isSwiping = true;
  }
});

fs.addEventListener('touchmove', (e) => {
  if (!isSwiping) return;
  const dx = e.touches[0].clientX - startX;
  const dy = e.touches[0].clientY - startY;

  // Only horizontal swipes
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30) {
    if (dx < 0 && current < images.length - 1) {
      // swipe left → next
      current++;
      render();
    } else if (dx > 0 && current > 0) {
      // swipe right → prev
      current--;
      render();
    }
    isSwiping = false; // prevent multiple triggers
  }
});

fs.addEventListener('touchend', () => {
  isSwiping = false;
});


  
  document.getElementById("closeGrid").onclick = () => {
// hide grid
  document.getElementById("grid").classList.add("hidden");

// show fullscreen
  document.getElementById("fullscreen").classList.remove("hidden");
  document.getElementById("fullscreen").classList.add("flex");

// make sure the image updates correctly
  render();
  };

    
  document.getElementById('prev').addEventListener('click', () => { if (current > 0) { current--; render(); } });
  document.getElementById('next').addEventListener('click', () => { if (current < images.length - 1) { current++; render(); } });
  
  document.getElementById('prev-area').addEventListener('click', () => { if (current > 0) { current--; render(); } });
  document.getElementById('next-area').addEventListener('click', () => { if (current < images.length - 1) { current++; render(); } });
  
  document.getElementById('gridBtn').addEventListener('click', function() {
    const fs = document.getElementById('fullscreen');
    const g = document.getElementById('grid');
    if (g.classList.contains('hidden')) {
      fs.classList.add('hidden');
      fs.classList.remove('flex');
      g.classList.remove('hidden');
      render();
    } else {
      fs.classList.remove('hidden');
      fs.classList.add('flex');
      g.classList.add('hidden');
    }
  });

  loadImages();

  // Reposition elements on window resize
  window.addEventListener('resize', () => {
    if (document.getElementById('fullscreen').classList.contains('flex')) {
      positionElements();
    }
  });

</script>

</body>
</html>
